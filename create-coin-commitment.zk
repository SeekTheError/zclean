
open String;
open Extended_lib;

//mh0 is a Merkel tree root - only public input
let main = fun ( mh0 : field), (nf : field)()) => {

// (1: validity & 2: ownership)
// I (1) know a route through the merkel tree {M0, M1, M2, M3} leading to a commitment we call t
// ie, hashed with its Merkel sibling M3, then all hashed with Merkel parent M2, then all hashed with Merkel grandparent M1
// gives Merkel root M0

// Further I (2) know a secret r, a value v and flag which concatenated and hashed give t.

// I know r, flag s.t. HS of {r,v,flag} = some t, s.t.
// t= HM (M0,(M1,(M2,(M3, t))))

// (3: non-inflation)
// TODO: My output value vo is (lt)equal to the value v of the original coin
// v=1

// (4: Flag-carrying)
// TODO: My output commitment does not add extra 'bits' to the flag
// TODO: ie, flag*discarded_flags = flag
// My output commitment has the same flag to the flag of the previous commitment

//TODO: make nullifier safe by using hash not multiply.
// (5: nullifiability)
// The nullifier n refers to that commitment t.
// ie safer (hashed) version of r*n=t

//NB: In variable names, xxx_bool is generally used to refer to the list(boolean) version of a value. _Not_ bool/ list(bool) !


let hash_bits = fun (pre_image : list(boolean)) => {
  let params = "bn128-params";
  Pedersen.digest_bits(params, pre_image);
};

let hash_field = (pre_image : field) => {
  let params = "bn128-params";
  Pedersen.digest_bits(params, to_bits(pre_image));
};

let order_fields = fun (a: field, b_tuple: (field, boolean)) => {
  let (b, lr_bit_b) = b_tuple;
  let result = select(lr_bit_b, ~then_=(a,b), ~else_=(b,a));

  // append (dir*a, not dir*b, not dir * a, dir * b)
  // .filter (nonzero)
  // .map (field -> list(bool))
  // return result[0]::result[1];
}

let hash_commitment = fun (secret : field, val1 : field, val2 : field) =>  {
  let secret_bool = to_bits(secret);
  let val1_bool = to_bits(val1);
  let val2_bool = to_bits(val2);
  let hashable = secret_bool@val1_bool@val2_bool ;

  //TODO: check bit length of 3way concat (defaults are OK? )
  hash_bits(hashable);
};


let hash_merkle_nodes = fun (ordered_nodes_tuple : (field, field)) => {
  let val1_bool = to_bits( fst(ordered_nodes_tuple) );
  let val2_bool = to_bits( snd(ordered_nodes_tuple) );

  hash_bits ( val1_bool, val2_bool ) ;
};

TODO: // pass private inputs to Prover
  let y = Prover {
    Get the following:
    v : field, flag : field, l1_sibling : (field, boolean), l2_sibling : (field, boolean), l3_sibling : (field, boolean)
   r,flag,r',flag', v ,v' //randomness and flag of the old and new cm (' are the new)
   // if (Field.is_square(x)) {
   //   Field.sqrt(x);
   // } else {
   //   0;
   // };
  };


  let t = hash_commitment (r, v, flag);

  let level3_tuple = hash_merkle_nodes(order_fields(t, l3_sibling));
  let level2_tuple = hash_merkle_nodes(order_fields(level3_tuple, level2_tuple));
  let level1_tuple = hash_merkle_nodes(order_fields(level2_tuple, level1_tuple));
  let calculated_root = hash_merkle_nodes(order_fields(level1_tuple, level2_tuple));

  // nullifier will require second hashing with secret in order to sign that it refers to this commitment and not another
  // maliciously signed with the same secret but different values
  let n = hash_nullifier_commitment (r, t);

  assert_r1(calculated_root, 1, M0);
 // assert_r1(t, 1, t);
  assert_r1(v, 1, v');
  assert_r1(flag, 1, flag');
  assert_r1(n, 1, nf);
};
